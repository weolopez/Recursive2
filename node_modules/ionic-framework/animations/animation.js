var dom_1 = require('../util/dom');
var util_1 = require('../util/util');
/**
 * @private
 **/
var Animation = (function () {
    function Animation(ele, opts) {
        if (opts === void 0) { opts = {}; }
        this._wChg = false;
        this._reset();
        this.element(ele);
        this._opts = util_1.assign({
            renderDelay: 24
        }, opts);
    }
    Animation.prototype._reset = function () {
        this._c = [];
        this._fx = {};
        this._bfSty = {};
        this._bfAdd = [];
        this._bfRmv = [];
        this._afSty = {};
        this._afAdd = [];
        this._afRmv = [];
        this._pFns = [];
        this._fFns = [];
        this._fOnceFns = [];
        this._clearAsync();
        this.isPlaying = this.hasTween = this._rv = false;
        this._el = this._easing = this._dur = null;
    };
    Animation.prototype.element = function (ele) {
        if (ele) {
            if (ele.nativeElement) {
                ele = ele.nativeElement;
            }
            else if (typeof ele === 'string') {
                ele = doc.querySelector(ele);
            }
            if (ele && ele.nodeType === 1) {
                this._el = ele;
                // does this element suport will-change property?
                this._wChg = ('opacity' in ele.style);
            }
        }
        return this;
    };
    Animation.prototype.parent = function (parentAnimation) {
        this._parent = parentAnimation;
        return this;
    };
    Animation.prototype.add = function (childAnimation) {
        childAnimation.parent(this);
        this._c.push(childAnimation);
        return this;
    };
    Animation.prototype.getDuration = function () {
        return this._dur !== null ? this._dur : (this._parent && this._parent.getDuration()) || 0;
    };
    Animation.prototype.duration = function (milliseconds) {
        this._dur = milliseconds;
        return this;
    };
    Animation.prototype.getEasing = function () {
        return this._easing !== null ? this._easing : (this._parent && this._parent.getEasing()) || null;
    };
    Animation.prototype.easing = function (name) {
        this._easing = name;
        return this;
    };
    Animation.prototype.from = function (prop, val) {
        return this._addProp('from', prop, val);
    };
    Animation.prototype.to = function (prop, val) {
        return this._addProp('to', prop, val);
    };
    Animation.prototype.fromTo = function (prop, fromVal, toVal) {
        return this.from(prop, fromVal).to(prop, toVal);
    };
    Animation.prototype._addProp = function (state, prop, val) {
        if (!this._fx[prop]) {
            this._fx[prop] = {
                trans: (TRANSFORMS.indexOf(prop) > -1)
            };
            if (this._fx[prop].trans) {
                this._fx[prop].wc = 'transform';
            }
            else if (prop === 'opacity') {
                this._fx[prop].wc = prop;
            }
        }
        var fx = this._fx[prop][state] = {
            val: val,
            num: null,
            unit: '',
        };
        if (typeof val === 'string' && val.indexOf(' ') < 0) {
            var r = val.match(/(^-?\d*\.?\d*)(.*)/);
            var num = parseFloat(r[1]);
            if (!isNaN(num)) {
                fx.num = num;
            }
            fx.unit = (r[0] != r[2] ? r[2] : '');
        }
        else if (typeof val === 'number') {
            fx.num = val;
        }
        return this;
    };
    Animation.prototype.fadeIn = function () {
        return this.fromTo('opacity', 0.001, 1);
    };
    Animation.prototype.fadeOut = function () {
        return this.fromTo('opacity', 0.999, 0);
    };
    Object.defineProperty(Animation.prototype, "before", {
        get: function () {
            var _this = this;
            return {
                addClass: function (className) {
                    _this._bfAdd.push(className);
                    return _this;
                },
                removeClass: function (className) {
                    _this._bfRmv.push(className);
                    return _this;
                },
                setStyles: function (styles) {
                    _this._bfSty = styles;
                    return _this;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "after", {
        get: function () {
            var _this = this;
            return {
                addClass: function (className) {
                    _this._afAdd.push(className);
                    return _this;
                },
                removeClass: function (className) {
                    _this._afRmv.push(className);
                    return _this;
                },
                setStyles: function (styles) {
                    _this._afSty = styles;
                    return _this;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Animation.prototype.play = function (opts) {
        if (opts === void 0) { opts = {}; }
        var self = this;
        var i;
        var duration = util_1.isDefined(opts.duration) ? opts.duration : self._dur;
        void 0;
        // always default that an animation does not tween
        // a tween requires that an Animation class has an element
        // and that it has at least one FROM/TO effect
        // and that the FROM/TO effect can tween numeric values
        self.hasTween = false;
        // fire off all the onPlays
        for (i = 0; i < self._pFns.length; i++) {
            self._pFns[i]();
        }
        this.isPlaying = true;
        // this is the top level animation and is in full control
        // of when the async play() should actually kick off
        // if there is no duration then it'll set the TO property immediately
        // if there is a duration, then it'll stage all animations at the
        // FROM property and transition duration, wait a few frames, then
        // kick off the animation by setting the TO property for each animation
        // stage all of the before css classes and inline styles
        // will recursively stage all child elements
        self._before();
        // ensure all past transition end events have been cleared
        this._clearAsync();
        if (duration > 30) {
            // this animation has a duration, so it should animate
            // place all the elements with their FROM properties
            // set the FROM properties
            self._progress(0);
            self._willChange(true);
            // set the async TRANSITION END event
            // and run onFinishes when the transition ends
            self._asyncEnd(duration);
            // begin each animation when everything is rendered in their place
            // and the transition duration/easing is ready to go
            dom_1.rafFrames(self._opts.renderDelay / 16, function () {
                // there's been a moment and the elements are in place
                // now set the TRANSITION duration/easing
                self._setTrans(duration, false);
                // wait a few moments again to wait for the transition
                // info to take hold in the DOM
                dom_1.raf(function () {
                    // browser had some time to render everything in place
                    // and the transition duration/easing is set
                    // now set the TO properties
                    // which will trigger the transition to begin
                    self._progress(1);
                });
            });
        }
        else {
            // this animation does not have a duration, so it should not animate
            // just go straight to the TO properties and call it done
            self._progress(1);
            // since there was no animation, immediately run the after
            self._after();
            // since there was no animation, it's done
            // fire off all the onFinishes
            self._onFinish();
        }
    };
    Animation.prototype.stop = function (opts) {
        if (opts === void 0) { opts = {}; }
        var self = this;
        var duration = util_1.isDefined(opts.duration) ? opts.duration : 0;
        var stepValue = util_1.isDefined(opts.stepValue) ? opts.stepValue : 1;
        // ensure all past transition end events have been cleared
        this._clearAsync();
        // set the TO properties
        self._progress(stepValue);
        if (duration > 30) {
            // this animation has a duration, so it should animate
            // place all the elements with their TO properties
            // now set the TRANSITION duration
            self._setTrans(duration, true);
            // set the async TRANSITION END event
            // and run onFinishes when the transition ends
            self._asyncEnd(duration);
        }
        else {
            // this animation does not have a duration, so it should not animate
            // just go straight to the TO properties and call it done
            self._after();
            // since there was no animation, it's done
            // fire off all the onFinishes
            self._onFinish();
        }
    };
    Animation.prototype._asyncEnd = function (duration) {
        var self = this;
        function onTransitionEnd(ev) {
            void 0;
            // ensure transition end events and timeouts have been cleared
            self._clearAsync();
            // set the after styles
            self._after();
            self._willChange(false);
            self._onFinish();
        }
        // set the TRANSITION END event on one of the transition elements
        self._unregTrans = dom_1.transitionEnd(self._transEl(), onTransitionEnd);
        // set a fallback timeout if the transition end event never fires
        self._tmr = setTimeout(onTransitionEnd, duration + 300);
    };
    Animation.prototype._clearAsync = function () {
        this._unregTrans && this._unregTrans();
        clearTimeout(this._tmr);
    };
    Animation.prototype._progress = function (stepValue) {
        // bread 'n butter
        var i, prop, fx, val, transforms, tweenEffect;
        for (i = 0; i < this._c.length; i++) {
            this._c[i]._progress(stepValue);
        }
        if (this._el) {
            // flip the number if we're going in reverse
            if (this._rv) {
                stepValue = ((stepValue * -1) + 1);
            }
            transforms = [];
            for (prop in this._fx) {
                if (this._fx.hasOwnProperty(prop)) {
                    fx = this._fx[prop];
                    if (fx.from && fx.to) {
                        tweenEffect = (fx.from.num !== fx.to.num);
                        if (tweenEffect) {
                            this.hasTween = true;
                        }
                        if (stepValue === 0) {
                            // FROM
                            val = fx.from.val;
                        }
                        else if (stepValue === 1) {
                            // TO
                            val = fx.to.val;
                        }
                        else if (tweenEffect) {
                            // EVERYTHING IN BETWEEN
                            val = (((fx.to.num - fx.from.num) * stepValue) + fx.from.num) + fx.to.unit;
                        }
                        else {
                            val = null;
                        }
                        if (val !== null) {
                            if (fx.trans) {
                                transforms.push(prop + '(' + val + ')');
                            }
                            else {
                                this._el.style[prop] = val;
                            }
                        }
                    }
                }
            }
            // place all transforms on the same property
            if (transforms.length) {
                if (!this._wChg) {
                    // if the element doesn't support will-change
                    // then auto add translateZ for transform properties
                    transforms.push('translateZ(0px)');
                }
                this._el.style[dom_1.CSS.transform] = transforms.join(' ');
            }
        }
    };
    Animation.prototype._setTrans = function (duration, forcedLinearEasing) {
        // set the TRANSITION properties inline on the element
        for (var i = 0; i < this._c.length; i++) {
            this._c[i]._setTrans(duration, forcedLinearEasing);
        }
        if (this._el && Object.keys(this._fx).length) {
            // all parent/child animations should have the same duration
            this._el.style[dom_1.CSS.transitionDuration] = duration + 'ms';
            // each animation can have a different easing
            var easing = (forcedLinearEasing ? 'linear' : this.getEasing());
            if (easing) {
                this._el.style[dom_1.CSS.transitionTimingFn] = easing;
            }
        }
    };
    Animation.prototype._willChange = function (addWillChange) {
        var i, wc, prop;
        for (i = 0; i < this._c.length; i++) {
            this._c[i]._willChange(addWillChange);
        }
        if (this._wChg) {
            if (addWillChange) {
                wc = [];
                for (prop in this._fx) {
                    if (this._fx.hasOwnProperty(prop)) {
                        if (this._fx[prop].wc !== '') {
                            wc.push(this._fx[prop].wc);
                        }
                    }
                }
                this._el.style['willChange'] = wc.join(',');
            }
            else {
                this._el.style['willChange'] = '';
            }
        }
    };
    Animation.prototype._before = function () {
        // before the RENDER_DELAY
        // before the animations have started
        var i, prop;
        // stage all of the child animations
        for (i = 0; i < this._c.length; i++) {
            this._c[i]._before();
        }
        if (!this._rv && this._el) {
            // css classes to add before the animation
            for (i = 0; i < this._bfAdd.length; i++) {
                this._el.classList.add(this._bfAdd[i]);
            }
            // css classes to remove before the animation
            for (i = 0; i < this._bfRmv.length; i++) {
                this._el.classList.remove(this._bfRmv[i]);
            }
            // inline styles to add before the animation
            for (prop in this._bfSty) {
                if (this._bfSty.hasOwnProperty(prop)) {
                    this._el.style[prop] = this._bfSty[prop];
                }
            }
        }
    };
    Animation.prototype._after = function () {
        // after the animations have finished
        var i, prop;
        for (i = 0; i < this._c.length; i++) {
            this._c[i]._after();
        }
        if (this._el) {
            // remove the transition duration/easing
            this._el.style[dom_1.CSS.transitionDuration] = '';
            this._el.style[dom_1.CSS.transitionTimingFn] = '';
            if (this._rv) {
                // finished in reverse direction
                // css classes that were added before the animation should be removed
                for (i = 0; i < this._bfAdd.length; i++) {
                    this._el.classList.remove(this._bfAdd[i]);
                }
                // css classes that were removed before the animation should be added
                for (i = 0; i < this._bfRmv.length; i++) {
                    this._el.classList.add(this._bfRmv[i]);
                }
                // inline styles that were added before the animation should be removed
                for (prop in this._bfSty) {
                    if (this._bfSty.hasOwnProperty(prop)) {
                        this._el.style[prop] = '';
                    }
                }
            }
            else {
                // finished in forward direction
                // css classes to add after the animation
                for (i = 0; i < this._afAdd.length; i++) {
                    this._el.classList.add(this._afAdd[i]);
                }
                // css classes to remove after the animation
                for (i = 0; i < this._afRmv.length; i++) {
                    this._el.classList.remove(this._afRmv[i]);
                }
                // inline styles to add after the animation
                for (prop in this._afSty) {
                    if (this._afSty.hasOwnProperty(prop)) {
                        this._el.style[prop] = this._afSty[prop];
                    }
                }
            }
        }
    };
    Animation.prototype.progressStart = function () {
        for (var i = 0; i < this._c.length; i++) {
            this._c[i].progressStart();
        }
        this._before();
        // force no duration, linear easing
        this._setTrans(0, true);
    };
    Animation.prototype.progressStep = function (stepValue) {
        stepValue = Math.min(1, Math.max(0, stepValue));
        for (var i = 0; i < this._c.length; i++) {
            this._c[i].progressStep(stepValue);
        }
        if (this._rv) {
            stepValue = ((stepValue * -1) + 1);
        }
        this._progress(stepValue);
    };
    Animation.prototype.progressEnd = function (shouldComplete, currentStepValue) {
        void 0;
        for (var i = 0; i < this._c.length; i++) {
            this._c[i].progressEnd(shouldComplete, currentStepValue);
        }
        // set all the animations to their final position
        this._progress(shouldComplete ? 1 : 0);
        // if it's already at the final position, or close, then it's done
        // otherwise we need to add a transition end event listener
        if (currentStepValue < 0.05 || currentStepValue > 0.95) {
            // the progress was already left off at the point that is finished
            // for example, the left menu was dragged all the way open already
            this._after();
            this._willChange(false);
            this._onFinish();
        }
        else {
            // the stepValue was left off at a point when it needs to finish transition still
            // for example, the left menu was opened 75% and needs to finish opening
            this._asyncEnd(64);
            // force quick duration, linear easing
            this._setTrans(64, true);
        }
    };
    Animation.prototype.onPlay = function (callback) {
        this._pFns.push(callback);
        return this;
    };
    Animation.prototype.onFinish = function (callback, onceTimeCallback, clearOnFinishCallacks) {
        if (onceTimeCallback === void 0) { onceTimeCallback = false; }
        if (clearOnFinishCallacks === void 0) { clearOnFinishCallacks = false; }
        if (clearOnFinishCallacks) {
            this._fFns = [];
            this._fOnceFns = [];
        }
        if (onceTimeCallback) {
            this._fOnceFns.push(callback);
        }
        else {
            this._fFns.push(callback);
        }
        return this;
    };
    Animation.prototype._onFinish = function () {
        this.isPlaying = false;
        var i;
        for (i = 0; i < this._fFns.length; i++) {
            this._fFns[i]();
        }
        for (i = 0; i < this._fOnceFns.length; i++) {
            this._fOnceFns[i]();
        }
        this._fOnceFns = [];
    };
    Animation.prototype.reverse = function (shouldReverse) {
        if (shouldReverse === void 0) { shouldReverse = true; }
        for (var i = 0; i < this._c.length; i++) {
            this._c[i].reverse(shouldReverse);
        }
        this._rv = shouldReverse;
        return this;
    };
    Animation.prototype.destroy = function (removeElement) {
        for (var i = 0; i < this._c.length; i++) {
            this._c[i].destroy(removeElement);
        }
        if (removeElement && this._el) {
            this._el.parentNode && this._el.parentNode.removeChild(this._el);
        }
        this._reset();
    };
    Animation.prototype._transEl = function () {
        // get the lowest level element that has an Animation
        var targetEl, i;
        for (i = 0; i < this._c.length; i++) {
            targetEl = this._c[i]._transEl();
            if (targetEl) {
                return targetEl;
            }
        }
        return (this.hasTween ? this._el : null);
    };
    /*
     STATIC CLASSES
     */
    Animation.create = function (name, opts) {
        if (opts === void 0) { opts = {}; }
        var AnimationClass = AnimationRegistry[name];
        if (!AnimationClass) {
            // couldn't find an animation by the given name
            // fallback to just the base Animation class
            AnimationClass = Animation;
        }
        return new AnimationClass(null, opts);
    };
    Animation.register = function (name, AnimationClass) {
        AnimationRegistry[name] = AnimationClass;
    };
    return Animation;
})();
exports.Animation = Animation;
var doc = document;
var TRANSFORMS = [
    'translateX', 'translateY', 'translateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ',
    'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'perspective'];
var AnimationRegistry = {};
